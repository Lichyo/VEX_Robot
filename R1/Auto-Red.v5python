{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\ngps_5 = Gps(Ports.PORT5, 0.00, -180.00, MM, 180)\n\nleft_wheel = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nright_wheel = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\ndriver = DriveTrain(left_wheel, right_wheel, 319.19, 295, 40, MM, 1)\ndrivertrain_gps = Gps(Ports.PORT5, 0.00, 200.00, MM, 180)\ngraper_motor = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\ngraper = DriveTrain(graper_motor, graper_motor, 319.19, 295, 40, MM, 1)\nclaw_motor = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\nclaw = DriveTrain(claw_motor, claw_motor, 319.19, 295, 40, MM, 1)\ncheck_green = Event()\ncontroller = Controller()\nvision_20__GREENBOX = Signature(1, -5727, -3817, -4772,-5847, -3731, -4789,2.5, 0)\nvision_20 = Vision(Ports.PORT20, 39, vision_20__GREENBOX)\nis_claw_activated = False\nhas_object = False\nstartCorrecting = False\n\n\nx = 0\ny = 0\nhead = 0\ncount = 0\na = 0\nb = 0\nc = 0 \ncorrect_angle_in_radian = 0\n\n\ndef broadcasting():\n    check_green.broadcast_and_wait()\n\ndef has_green_callback():\n    global has_object\n    global startCorrecting\n    objects = vision_20.take_snapshot(0)\n    objects = vision_20.largest_object()\n    wait(0.1, SECONDS)\n    center_x = objects.centerX\n    \n    w = objects.width \n    h = objects.height\n\n    # find out object\n    if w > 205 and h > 130:\n        graper.stop()\n        driver.drive(REVERSE, 40)\n        wait(0.3, SECONDS)\n        driver.stop()\n        has_object = True\n        startCorrecting = True\n\n    else :\n        graper.drive(FORWARD,150)\n        if center_x < 130:\n            driver.turn_for(LEFT, 5,DEGREES)\n            driver.drive(FORWARD,45)\n        elif center_x > 190:\n            driver.turn_for(RIGHT, 5, DEGREES)\n            driver.drive(FORWARD,45)\n        else : \n            driver.drive(FORWARD, 45)\n\ncheck_green(has_green_callback)\n\ndef position():\n    global x\n    global y \n    global head\n    global correct_angle_in_radian\n    global a\n    global b\n    global c\n    x0 = -1100\n    y0 = 0\n\n    x = drivertrain_gps.x_position(MM)\n    y = drivertrain_gps.y_position(MM)\n    head = drivertrain_gps.heading()\n    a = abs(x-x0)\n    c = abs(y-y0)\n    b = math.sqrt(math.pow(a,2)+math.pow(c,2))\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print('x: ',x)\n    brain.screen.print(' y: ',y)\n    brain.screen.print(' head: ',head)\n    brain.screen.print(' theta: ',correct_angle_in_radian)\n    return head\n    \n\ndef theta():\n    position()\n    global a\n    global b\n    global c\n    global correct_angle_in_radian\n\n    cos = a/b\n    correct_angle_in_radian = math.acos(cos)\n    correct_angle_in_radian = math.degrees(correct_angle_in_radian)\n    \n    return correct_angle_in_radian\n\n \ndef claw_activating():\n    global is_claw_activated\n    claw.drive_for(FORWARD, 840, MM)\n    claw.stop()\n    wait(1, SECONDS)\n    claw.drive_for(REVERSE,120,MM)\n    wait(0.1,SECONDS)\n    claw.set_stopping(HOLD)\n    claw.stop()\n    wait(1,SECONDS)\n    is_claw_activated = True\n\ndef claw_deactivating():\n    global is_claw_activated\n    claw.set_stopping(COAST)\n    claw.drive_for(REVERSE, 750, MM)\n    claw.stop()\n    is_claw_activated = False\n\ndef preparing_and_shooting():\n    global x\n    global has_object\n    while x > 520:\n        position()\n        wait(0.1, SECONDS)\n        driver.drive(REVERSE,80)\n\n    driver.stop()\n    wait(0.1,SECONDS)\n    claw.drive_for(FORWARD,800,MM)\n    graper.drive(REVERSE,80)\n    wait(2,SECONDS)\n    graper.stop()\n    claw.set_stopping(COAST)\n    claw.drive_for(REVERSE,800,MM)\n    claw.stop()\n    wait(0.3,SECONDS)\n\n    driver.drive(FORWARD, 100)\n    wait(2.8, SECONDS)\n    driver.stop()\n    has_object = False\n    \n\ndef moving_to_goal(turn_for_correction):\n    global head\n    position()\n    wait(0.1, SECONDS)\n\n    while not(head < (turn_for_correction + 1) and head > (turn_for_correction - 1)):\n        position()\n        adjust_direction(turn_for_correction)\n    \n    while x < 650:\n        position()\n        driver.drive(FORWARD, 50)\n    \ndef adjust_direction(correct_angle):\n    global head\n    if head < correct_angle and head > correct_angle - 180:\n        driver.turn(RIGHT,10)\n    else:\n        driver.turn(LEFT,10)\n\ndef turn_to_90():\n    while not (head < 91 and head > 89):\n        position()\n        adjust_direction(90)\n\ndef move_to_offensive_zone():\n    global has_object\n    claw_activating()\n    claw.drive(FORWARD, 80)\n    wait(0.1, SECONDS)\n    driver.drive(FORWARD, 80)\n    wait(1.6, SECONDS)\n    claw_deactivating()\n    driver.stop()\n    wait(0.1, SECONDS)\n    driver.turn_for(LEFT, 90, DEGREES)\n    driver.stop()\n    driver.drive(FORWARD, 100)\n    wait(0.7, SECONDS)\n    driver.stop()\n    has_object = True\n\ngps_5.calibrate()\nwait(0.1,SECONDS)\n# move_to_offensive_zone()\n\nwhile True:\n    if not has_object:\n        if not is_claw_activated:\n            claw_activating()   \n        else:\n            broadcasting()  # Finding Object\n    else:\n        if is_claw_activated:\n            claw_deactivating()\n        position()\n        wait(0.1, SECONDS)\n        if y > 0:\n            moving_to_goal(90 + theta())\n            position()\n            wait(0.1, SECONDS)\n            turn_to_90()                \n            preparing_and_shooting()\n            \n        else :\n            moving_to_goal(90 - theta())\n            position()\n            wait(0.1, SECONDS)\n            turn_to_90()\n            preparing_and_shooting()","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.2","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}